context("test: get_matched_peaks")

test_that("Testing get matched peaks function", {

  # Download required test files------------------------------------------------

  source(system.file("tests/testthat/file_check.R", package = "pspecterlib"))
  downfolder <- file_check("downfolder")
  BU_ScanMetadata <- file_check("BU")
  BU_Peak <- get_peak_data(ScanMetadata = BU_ScanMetadata, ScanNumber = 31728)

  # Test get_peak_data input checks---------------------------------------------

  # Scan Metadata must be of the appropriate class
  expect_error(
    get_matched_peaks(data.frame(test = 1)),
    "ScanMetadata must be a scan_metadata object generated by get_scan_metadata."
  )

  # Peak data must be of the appropriate class
  expect_error(
    get_matched_peaks(BU_ScanMetadata, data.frame(test = 1)),
    "PeakData must be a peak_data object generated by get_peak_data."
  )

  # PPM Threshold must be an appropriate number
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      PPMThreshold = "12"
    ),
    "PPMThreshold must be a single number."
  )

  # Ion Groups cannot be larger than 6
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      IonGroups = c("a", "b", "c", "x", "y", "z", "aa")
    ),
    "IonGroups cannot be longer than length 6."
  )

  # Ion Groups must contain any combination of a, b, c, x, y, and z
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      IonGroups = c("aa")
    ),
    "IonGroups must only contain the letters a, b, c, x, y, and z."
  )

  # Calculate Isotopes must be a true or false
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      CalculateIsotopes = NA
    ),
    "CalculateIsotopes must be a single logical value TRUE or FALSE."
  )

  # Minimum Abundance must be a numeric
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      MinimumAbundance = "2"
    ),
    "MinimumAbundance must be a single numeric value. For example, 0.1."
  )
  
  # MinimumAbundance can't be larger than 100
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      MinimumAbundance = 100.5
    ),
    "MinimumAbundance must be between 0 and 100."
  )

  # Correlation Score must be a numeric
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      CorrelationScore = "2"
    ),
    "CorrelationScore must be a single numeric value. For example, 0.1."
  )

  # Correlation Score must be between 0 and 1
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      CorrelationScore = 2
    ),
    "CorrelationScore must be between 0 and 1."
  )
  
  # MatchingAlgorithm must be one of two options
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      MatchingAlgorithm = "yummytoast"
    ),
    "MatchingAlgorithm must be 'closest peak' or 'highest abundance'"
  )

  # Alternative Sequence must be a valid protein sequence
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      AlternativeSequence = "INVALIDSEQUENCE"
    ),
    "The detected sequence: INVALIDSEQUENCE is not acceptable."
  )

  # Alternative Spectrum must be a valid spectrum
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      AlternativeSpectrum = data.frame(test = 1)
    ),
    "AlternativeSpectrum must be made with make_peak_data."
  )

  # Alternative Charge must be a single numeric
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      AlternativeCharge = c(2, 3)
    ),
    "AlternativeCharge must be a single number."
  )

  # Alternative Charge must be a single numeric
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      AlternativeCharge = c(2, 3)
    ),
    "AlternativeCharge must be a single number."
  )

  # AlternativeIonGroups must be from the make_modified_ions function
  expect_error(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = BU_Peak,
      AlternativeIonGroups = data.frame(test = 1)
    ),
    "AlernativeIonGroups must be of the class 'modified_ion' from make_mass_modified_ion."
  )

  # Create a matched_peaks object-----------------------------------------------

  # First, run the defaults
  BU_MatchedPeaks <- get_matched_peaks(BU_ScanMetadata, BU_Peak, CorrelationScore_FilterNA = TRUE)
  expect_true(inherits(BU_MatchedPeaks, "matched_peaks"))

  # Second, run an example with alternatives
  BU_MatchedPeaks2 <- get_matched_peaks(
    AlternativeSpectrum = make_peak_data(MZ = BU_Peak$`M/Z`, Intensity = BU_Peak$Intensity),
    AlternativeCharge = 2,
    AlternativeSequence = "TESTTEST[Acetyl]TESTTEST",
    AlternativeIonGroups = make_mass_modified_ion(Ion = "a", Symbol = "+", AMU_Change = 1),
  )
  expect_null(BU_MatchedPeaks2)
  
  # Trigger a multiple sequences message
  expect_message(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = get_peak_data(BU_ScanMetadata, 29135)
    ),
    "Multiple sequences detected. Select one and pass it to AlternativeSequence. Your options are: RVPHPAYGKEKIPAYDMIK, ADAKTDKPKAEVVETVTDAPK"
  )
  
  # Trigger a NA sequence
  expect_message(
    get_matched_peaks(
      ScanMetadata = BU_ScanMetadata,
      PeakData = get_peak_data(BU_ScanMetadata, 29126)
    ),
    "Sequence is NA"
  )
  
  # Use an alternative glossary
  Glossary <- data.table::fread(system.file("extdata", "Unimod_v20220602.csv", package = "pspecterlib"))
  BU_MatchedPeaks3 <- get_matched_peaks(PeakData = BU_Peak, 
                                        AlternativeSequence = "IGA[Acetyl]VGGTENVSLTQSQMPAHNHLVAASTVSGTVKPLANDIIGAGLNK", 
                                        AlternativeCharge = 5,
                                        AlternativeGlossary = Glossary[Glossary$Modification == "Acetyl",])
  BU_MatchedPeaks4 <- get_matched_peaks(ScanMetadata = BU_ScanMetadata, 
                                        PeakData = get_peak_data(BU_ScanMetadata, 32058),
                                        AlternativeGlossary = Glossary[Glossary$Modification == "Oxidation",],
                                        AlternativeIonGroups = make_mass_modified_ion(Ion = c("b", "z"),
                                                                                      Symbol = c("+", "+"),
                                                                                      AMU_Change = c(1.00727647, 1.00727647)),
                                        MatchingAlgorithm = "highest abundance")
  
  # Filter everything!! 
  BU_MatchPeaks5 <- get_matched_peaks(BU_ScanMetadata, BU_Peak, CorrelationScore_FilterNA = TRUE, CorrelationScore = 1)
  expect_null(BU_MatchPeaks5)

})
