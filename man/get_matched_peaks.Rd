% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_matched_peaks.R
\name{get_matched_peaks}
\alias{get_matched_peaks}
\title{Matches Calculated Fragments to the Experimental Spectrum and creates the "Matched Peak" object}
\usage{
get_matched_peaks(
  ScanMetadata = NULL,
  PeakData = NULL,
  PPMThreshold = 10,
  IonGroups = c("a", "b", "c", "x", "y", "z"),
  CalculateIsotopes = TRUE,
  MinimumAbundance = 1,
  CorrelationScore = 0,
  MatchingAlgorithm = "closest peak",
  IsotopeAlgorithm = "Rdisop",
  AlternativeIonGroups = NULL,
  AlternativeSequence = NULL,
  AlternativeSpectrum = NULL,
  AlternativeCharge = NULL,
  AlternativeGlossary = NULL,
  ...
)
}
\arguments{
\item{ScanMetadata}{Object of the scan_metadata class from get_scan_metadata. Required,
unless an alternative spectrum, sequence, and charge is provided.}

\item{PeakData}{Object of the peak_data class from get_peak_data. Required,
unless an alternative spectrum, sequence, and charge is provided.}

\item{PPMThreshold}{The ppm error threshold between calculated fragments. Default is 10. Required.}

\item{IonGroups}{Determine which ion types to calculate. a, b, c, x, y, z are supported. Default
is c("a", "b", "c", "x", "y", "z"). Required.}

\item{CalculateIsotopes}{A logical which indicates whether isotopes should be calculated.
FALSE = Faster Calculations. Default is TRUE. Required.}

\item{CorrelationScore}{A minimum correlation score to filter isotopes by. Range is 0 to 1.
Default is 0. There is a 3 peak minimum to calculate a correlation score. Required.}

\item{MatchingAlgorithm}{Either "closest peak" or "highest abundance" where the "closest
peak" implementation chooses the peak closest to the true M/Z value within the PPM window
and "highest abundance" chooses the highest intensity peak within the PPM window. "closest peak"
is recommended for peaks that have been peak picked with an external tool, 
and "highest abundance" is recommended for noisy datasets or those with many peaks.}

\item{IsotopeAlgorithm}{"isopat" uses the isopat package to calculate isotopes, while 
"Rdisop" uses the Rdisop package. Though more accurate, Rdisop has been known to 
crash on Windows computers when called iteratively more than 1000 times. 
Default is Rdisop, though isopat is an alternative.}

\item{AlternativeIonGroups}{A "modified_ion" object from "make_mass_modified ions." Default is NULL.}

\item{AlternativeSequence}{A proforma-acceptable string to calculate the literature 
fragments. The default is the sequence matched in the ScanMetadata file. Default is NULL.}

\item{AlternativeSpectrum}{An alternative "peak_data" spectrum to use instead of the default 
PeakData. Mostly used by other packages. Default is NULL.}

\item{AlternativeCharge}{A different charge value to test besides the one in the PeakData 
spectrum.}

\item{AlternativeGlossary}{Try a different glossary. See system.file("extdata", "Unimod_v20220602.csv", package = "pspecterlib)
for formatting.}

\item{MinAbundance}{Minimum abundance for calculating isotopes. Default is 0.1.}
}
\description{
Returns the "matched_peaks" object with experimental spectrum
   annotated with matches to calculated fragments.
}
\details{
The data.table outputted by this function contains 17 columns.
\tabular{ll}{
M/Z \tab The calculated M/Z value of the fragment \cr
\tab \cr
Ion \tab The ion's type (a, b, c, x, y, or z) with the ion's position, oriented by terminus: N-terminus (a-c) or C-terminus (x-z) \cr
\tab \cr
Type \tab The ion's type (a, b, c, x, y, or z) with modified ion annotations (z*) if applicable \cr
\tab \cr
Position \tab The ion's position, oriented by terminus \cr
\tab \cr
Z \tab The charge of the fragment \cr
\tab \cr
Sequence \tab The peptide sequence of the fragment \cr
\tab \cr
N Position \tab The ion's position, oriented by only the N-terminus \cr
\tab \cr
General Type \tab The ion's type, removing modified ion annotation (z* would be z) \cr
\tab \cr
Modifications \tab Any PTMs assigned to this fragment. If none, the string will be "" \cr
\tab \cr
M/Z Tolerance \tab Based on the inputted PPM Tolerance, this value indicates how far off the calculated M/Z and Experimental M/Z can be. \cr
\tab \cr
M/Z Experimental \tab The experimental M/Z value that was matched to the calculated M/Z value for that fragment. \cr
\tab \cr
Intensity Experimental \tab The experimental intensity for the experimental M/Z value \cr
\tab \cr
PPM Error \tab A calculated value to indicate how far off the experimental and calculated value are from each other, in parts per million (PPM) \cr
\tab \cr
Molecular Formula \tab The formula of the sequence at that fragment. Used to determine isotopic percentages \cr
\tab \cr
Isotope \tab Annotation of isotopes in the M+n format, where M+0 is the non-isotope peak, and each successive isotope is M+1, M+2, etc. \cr
\tab \cr
Isotopic Percentage \tab The calculated intensity, proportional to M+0. For example, if M+1 has an isotopic percentage of 0.5, it is half the size of M+0. \cr
\tab \cr
Correlation Score \tab If at least two isotopes are recorded, a cosine correlation score of calculated and experimental intensities is determined for these 3+ fragments. \cr
\tab \cr
Residue \tab Name of the C-terminal residue. Used in downstream functions. \cr
\tab \cr
}


Objects of the class "matched_peaks" contain attributes that are referenced by downstream functions.
    The attributes are the input parameters as well as coverage (number of residues with an ion annotation,
    over the length of the peptide minus 1), and the median ppm error for all the fragments in
    the spectra.
}
\examples{
\dontrun{

# Test bottom up data
BU_Peak <- get_peak_data(ScanMetadata = BU_ScanMetadata, ScanNumber = 31728)
BU_Match <- get_matched_peaks(ScanMetadata = BU_ScanMetadata, PeakData = BU_Peak)

# Test bottom up data with a PTM
BU_Match2 <- get_matched_peaks(
  ScanMetadata = BU_ScanMetadata,
  PeakData = BU_Peak,
  AlternativeSequence = "M.IGAV[Acetyl]GGTENVSLTQSQMPAHNHLVAASTVSGTVKPLANDIIG[20.1]AGLNK" 
)

# Test bottom up data with a mass modified ion 
BU_Match3 <- get_matched_peaks(
 ScanMetadata = BU_ScanMetadata,
 PeakData = BU_Peak, 
 IonGroups = "b",
 AlternativeIonGroups = make_mass_modified_ion(Ion = "y", Symbol = "^", AMU_Change = 1.00727647)
)


# Test with top down data
TD_Peak <- get_peak_data(ScanMetadata = TD_ScanMetadata, ScanNumber = 5709)
TD_Match <- get_matched_peaks(ScanMetadata = TD_ScanMetadata, PeakData = TD_Peak)

}

}
